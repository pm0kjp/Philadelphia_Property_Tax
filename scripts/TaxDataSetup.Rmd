---
title: "Philadelphia_Property_Tax_Data"
author: "Joy Payton"
date: "12/3/2016"
output: pdf_document
---

```{r}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE)
```

## Load Libraries

```{r}
library(dplyr)
library(jsonlite)
```

## Obtain Data 

We can get property tax delinquency data from Philadelphia's Open Data site:

```{r}
csv <- "https://data.phila.gov/api/views/4v5p-qi2q/rows.csv?accessType=DOWNLOAD&bom=true"
taxDataWhole <- read.csv(csv, stringsAsFactors = FALSE)
taxData <- taxDataWhole %>% select(Parcel.Number, Location,
                              Owner, Tax.Period, Total, Coordinates)
```

We'll also get property assessments from the Office of Property Assessments, 
which can tell us more about properties -- most helpfully, their census tracts!

```{r}
csv <- "https://data.phila.gov/api/views/3h6i-2hfj/rows.csv"
assessmentDataWhole <- read.csv(csv, stringsAsFactors = FALSE)
assessmentData <- assessmentDataWhole %>% select(Parcel.Number, Location, 
                                            Owner.1, Owner.2, Census.Tract,
                                            Zip.Code, Geographic.Ward,
                                            Market.Value, Exterior.Condition,
                                            Coordinates)
rm(csv)
```

Finally, we can obtain a geoJSON file reflecting the Census tracts in 
Philadelphia.  This is helpful at this point for understanding the relationship
between various fields, such as tract and full geoID, for example.  We won't use
it otherwise in this script.

```{r}
tractData <- fromJSON("http://data.phl.opendata.arcgis.com/datasets/8bc0786524a4486bb3cf0f9862ad0fbf_0.geojson")
```

## Combine and Reshape Data -- First Time

Note that this section covers how to handle this data reshaping the first time.
Future times, we can make ample use of saved data that we got the first time!

Let's combine property data to get some enriched data about delinquent 
properties. We have duplicated data that appears in both data frames 
(like street address), which works in our favor for making sure that we're 
matching correctly.

```{r}
combined <- merge(x=taxData, y=assessmentData, all.x=TRUE, 
                  by=c("Parcel.Number","Location","Coordinates"))
```

Do we have census tracts on everyone?  Almost certainly not, given that our
assessment data had fewer rows than our tax data.

```{r}
table(is.na(combined$Census.Tract))
```

We've got a lot of NA's.  Let's fix that.  We can imagine that a lot of the 
latitude and longitude coordinates probably overlap between distinct parcels
(for example, condos in the same building, or next door neighbors).  So let's
make a table of just the coordinates and the census tract, and then use that
to populate coordinate matches!

We'll split out the complete and incomplete rows and then re-bind them.

```{r}
completeRows <- combined[!is.na(combined$Census.Tract),]
incompleteRows <- combined[is.na(combined$Census.Tract),]
incompleteRows$Census.Tract <- NULL
tractsIKnow <- unique(completeRows[completeRows$Coordinates !="",
                                   c("Coordinates","Census.Tract")])
additionalCompleteRows <- merge(x=incompleteRows, y=tractsIKnow,
                                by="Coordinates", all.x=TRUE)
```

How many new properties did we find tracts for?

```{r}
table(is.na(additionalCompleteRows$Census.Tract))
```

Only a couple thousand -- we still have thousands of properties for which we 
can't find tracts!  But let's add the ones we found to our completeRows and 
rebuild our "incompleteRows" with the ones we still don't have a tract for.

```{r}
completeRows <- bind_rows(completeRows, 
          additionalCompleteRows[!is.na(additionalCompleteRows$Census.Tract),])
```

```{r}
incompleteRows <- additionalCompleteRows[is.na(additionalCompleteRows$Census.Tract),]
```

It turns out that a lot of our incomplete rows are lacking both the coordinates
and the location -- there will be no way to locate those properties in a census
tract, at least not with our current data!  Let's remove those entirely.

```{r}
incompleteRows <- incompleteRows %>% filter(Coordinates!="" | Location != "")
```

That's still a lot of properties for which we do have some kind of location,
either an address and/or some geographic coordinates, but we don't have a tract.

Let's see if we can get down to just the unique coordinates in this group.

```{r}
coordinatesToGeocode <- as.data.frame(unique(incompleteRows$Coordinates))
names(coordinatesToGeocode) <- c("Coordinates")
```

OK!  That's less than 4k, so let's use an API and find out the census tract for
each of those coordinates.  First we'll have to split out the latitude and 
longitude:

```{r}
library(stringr)
coordinatesToGeocode$lat <- as.numeric(str_match(coordinatesToGeocode$Coordinates, 
                                               "\\((\\d+.\\d+),")[,2])
coordinatesToGeocode$long <- as.numeric(str_match(coordinatesToGeocode$Coordinates, 
                                                ",\\s+(.+)\\)")[,2])
```

Now let's create a function that will use  an FCC API to get the census tract 
for a given latitude and longitude.

```{r}
getTract <- function(latitude, longitude)
{
  tract <- vector(length = length(latitude))
  for (i in 1:length(latitude)) {
    lookup <- paste("http://data.fcc.gov/api/block/find?format=json&latitude=", 
                    latitude[i], "&longitude=", longitude[i],
                    sep="")
    response <- fromJSON(txt=lookup)
    tract[i] <- response$Block$FIPS
    if (i %% 100 == 0) {  # take a break every 100 -- no need to kill the API!
      Sys.sleep(5)
    }
  }
  return(tract)
}
```

As an aside, census tracts have state and county prefixes associated with them.
The Commonwealth of Pennsylvania has a code of 42, and Philadelphia County has
a code of 101.  So we'll need to adjust our tracts, since the ones we have so
far have been the "short" form, assuming that we know we're in Philadelphia, 
whereas the ones we're about to get from the FCC are full length.

This next bit takes awhile!  We can do it in batches of 1000 to give a tiny 
bit of throttling and allow for not losing everything if we overwhelm the API 
and it kicks us out.

```{r eval=FALSE}
coordinatesToGeocode$Census.Tract<-NA
coordinatesToGeocode <- coordinatesToGeocode %>% filter(Coordinates!="")
for (count in 0:39) {
  start <- 1000 * count + 1
  end <- 1000 * (count+1)
  coordinatesToGeocode$Census.Tract[start:end] <- 
      getTract(coordinatesToGeocode$lat[start:end], 
           coordinatesToGeocode$long[start:end])
  Sys.sleep(30)
}
coordinatesToGeocode$Census.Tract[40001:length(coordinatesToGeocode$tract)] <- 
  getTract(coordinatesToGeocode$lat[40001:length(coordinatesToGeocode$tract)], 
           coordinatesToGeocode$long[40001:length(coordinatesToGeocode$tract)])

```


Finally we have tracts for everyone with coordinates.  Let's merge these back
in:

```{r}
incompleteRows <- incompleteRows %>% select(-Census.Tract)
coordinatesToGeocode <- coordinatesToGeocode %>% select(-c(lat,long))
additionalCompleteRows <- merge(x=incompleteRows,y=coordinatesToGeocode, by="Coordinates", 
           all.x=TRUE)
```

And let's get our tracts reset to just the important values:

```{r}
additionalCompleteRows$Census.Tract <- 
  str_match(additionalCompleteRows$Census.Tract,"42101(\\d{4})\\d+")[,2]
```

Let's add our newly determined rows to the completeRows object, and reset our 
incomplete rows to see if there's something we can do for the properties that 
don't have coordinates. 

```{r}
completeRows <- bind_rows(completeRows, 
          additionalCompleteRows[!is.na(additionalCompleteRows$Census.Tract),])
incompleteRows <- additionalCompleteRows[is.na(additionalCompleteRows$Census.Tract),]
```

OK, out of over 700,000 rows, we only have 107 that we can't find tracts for, 
because they have no coordinates.  Let's see if maybe their street addresses 
line up with street addresses for which we have a coordinate!

```{r}
addresses <- data.frame(Location=unique(incompleteRows$Location))
addressesWithTracts <- unique(completeRows %>% select(Location, Census.Tract))
addresses <- merge(x=addresses, y=addressesWithTracts, by="Location",
                   all.x=TRUE)
```

Nope, these don't have an easy solution.  We could keep trying to track them
down, but let's leave them be for now.

Let's also save all that hard-earned tract data info!

```{r}
completeRows$Census.Tract <- as.numeric(completeRows$Census.Tract)
phillyCensusTracts <- unique(completeRows %>% select(Location, Coordinates,
                                                     Census.Tract))
write.csv(phillyCensusTracts, "phillyCensusTracts.csv", row.names = FALSE)
```

That way we won't have to do that long API call again!  I've stored this 
file in my GitHub.  That way, in the future, we can skip all of the above stuff 
and just do this...


## Combine and Reshape Data -- Subsequent Times

This avoids all that API nonsense if we already have the tract data set aside!

```{r}
combined <- merge(x=taxData, y=assessmentData, all.x=TRUE, 
                  by=c("Parcel.Number","Location","Coordinates"))
combined$Census.Tract <- as.numeric(combined$Census.Tract)
completeRows <- combined[!is.na(combined$Census.Tract),]
incompleteRows <- combined[is.na(combined$Census.Tract),]
incompleteRows$Census.Tract <- NULL
tractsIKnow <- unique(read.csv("phillyCensusTracts.csv") %>% 
                        select(-Location) %>% filter(Coordinates !=""))
additionalCompleteRows <- merge(x=incompleteRows, y=tractsIKnow,
                                by="Coordinates", all.x=TRUE)
completeRows <- bind_rows(completeRows, 
          additionalCompleteRows[!is.na(additionalCompleteRows$Census.Tract),])
incompleteRows <- additionalCompleteRows[is.na(additionalCompleteRows$Census.Tract),]
```
